{"version":3,"file":"userfront-core.js","sources":["../src/store.js","../src/utils.js","../src/user.js","../src/cookies.js","../src/tokens.js","../src/refresh.js","../src/url.js","../src/mfa.js","../src/signon.js","../src/logout.js","../src/constants.js","../src/mode.js","../src/user.methods.js","../src/index.js"],"sourcesContent":["export const store = {\n  user: {},\n  tokens: {},\n  mode: \"live\",\n};\n","/**\n * This file is for zero-dependency utilities that can\n * be imported by any other file. Don't add any imports\n * to this file other than constants\n */\n\n/**\n * Get the unverified base64 decoded payload of a JWT\n *\n * @param {String} token - JSON Web Token\n * @returns {Object}\n */\nexport function getJWTPayload(token) {\n  try {\n    const encodedPayload = token\n      .split(\".\")[1]\n      .replace(\"-\", \"+\")\n      .replace(\"_\", \"/\");\n    return JSON.parse(atob(encodedPayload));\n  } catch (error) {\n    console.error(\"Problem decoding JWT payload\", error);\n  }\n}\n\nexport function throwFormattedError(error) {\n  if (!error) return;\n  if (typeof error === \"string\") throw new Error(error);\n  if (error?.response?.data?.message) {\n    throw new Error(error.response.data.message);\n  }\n  throw error;\n}\n","import { store } from \"./store.js\";\nimport { getJWTPayload } from \"./utils.js\";\n\n/**\n * Define the store.user object based on the ID token\n */\nexport function setUser() {\n  if (!store.tokens.idToken) {\n    return console.warn(\"Cannot define user: missing ID token\");\n  }\n\n  store.user = store.user || {};\n  const idTokenPayload = getJWTPayload(store.tokens.idToken);\n\n  // Set basic user information properties from ID token\n  const propsToDefine = [\n    \"email\",\n    \"username\",\n    \"name\",\n    \"image\",\n    \"data\",\n    \"confirmedAt\",\n    \"createdAt\",\n    \"updatedAt\",\n    \"mode\",\n    \"userId\",\n    \"userUuid\",\n    \"tenantId\",\n    \"isConfirmed\",\n  ];\n  for (const prop of propsToDefine) {\n    if (prop === \"update\") return;\n    store.user[prop] = idTokenPayload[prop];\n  }\n}\n\n/**\n * Remove all user information\n */\nexport function unsetUser() {\n  for (const attr in store.user) {\n    if (typeof store.user[attr] !== \"function\") {\n      delete store.user[attr];\n    }\n  }\n}\n\n/**\n * Export the store.user object with the update method added\n */\nexport const user = store.user;\n","import Cookies from \"js-cookie\";\nimport { store } from \"./store.js\";\nimport { setTokensFromCookies, unsetTokens } from \"./tokens.js\";\n\n/**\n * Set a cookie value based on the given options.\n * @param {String} value\n * @param {Object} options\n * @param {String} type\n */\nexport function setCookie(value, options, type) {\n  const cookieName = `${type}.${store.tenantId}`;\n  options = options || {\n    secure: store.mode === \"live\",\n    sameSite: \"Lax\",\n  };\n  if (type === \"refresh\") {\n    options.sameSite = \"Strict\";\n  }\n  Cookies.set(cookieName, value, options);\n}\n\n/**\n * Remove a cookie by name, regardless of its cookie setting(s).\n * @param {String} name\n */\nfunction removeCookie(name) {\n  // Define all possible path and domain combinations\n  let paths, domains;\n  try {\n    const path = window.location.pathname;\n    const hostname = window.location.hostname;\n    const hostnameParts = hostname.split(\".\");\n    const primaryDomain = hostnameParts.slice(-2).join(\".\");\n    paths = [undefined, path, \"/\"];\n    domains = [\n      undefined,\n      hostname,\n      `.${hostname}`,\n      primaryDomain,\n      `.${primaryDomain}`,\n    ];\n  } catch (err) {\n    paths = [undefined, \"/\"];\n    domains = [undefined];\n  }\n\n  // Iterate over paths and domains, and remove cookies if present\n  paths.map((path) => {\n    domains.map((domain) => {\n      const options = {};\n      if (domain) options.domain = domain;\n      if (path) options.path = path;\n      Cookies.remove(name, options);\n    });\n  });\n}\n\n/**\n * Remove all auth cookies (access, id, refresh).\n */\nexport function removeAllCookies() {\n  removeCookie(store.tokens.accessTokenName);\n  removeCookie(store.tokens.idTokenName);\n  removeCookie(store.tokens.refreshTokenName);\n  unsetTokens();\n}\n\n/**\n * Set the cookies from a tokens object, and add to the local store.\n * @param {Object} tokens\n */\nexport function setCookiesAndTokens(tokens) {\n  setCookie(tokens.access.value, tokens.access.cookieOptions, \"access\");\n  setCookie(tokens.id.value, tokens.id.cookieOptions, \"id\");\n  if (tokens.refresh && tokens.refresh.value) {\n    setCookie(tokens.refresh.value, tokens.refresh.cookieOptions, \"refresh\");\n  }\n  setTokensFromCookies();\n}\n","import Cookies from \"js-cookie\";\nimport { store } from \"./store.js\";\nimport { setUser, unsetUser } from \"./user.js\";\nimport { refresh } from \"./refresh.js\";\n\nstore.tokens = store.tokens || {};\nstore.tokens.refresh = refresh;\n\nexport function setTokenNames() {\n  store.tokens = store.tokens || {};\n  store.tokens.accessTokenName = `access.${store.tenantId}`;\n  store.tokens.idTokenName = `id.${store.tenantId}`;\n  store.tokens.refreshTokenName = `refresh.${store.tenantId}`;\n}\n\n/**\n * Set and then return the access token\n */\nexport function accessToken() {\n  store.tokens.accessToken = Cookies.get(store.tokens.accessTokenName);\n  return store.tokens.accessToken;\n}\n\n/**\n * Set and then return the ID token\n */\nexport function idToken() {\n  store.tokens.idToken = Cookies.get(store.tokens.idTokenName);\n  return store.tokens.idToken;\n}\n\n/**\n * Define the store token values from the cookie values.\n */\nexport function setTokensFromCookies() {\n  const tokenNames = [\"access\", \"id\", \"refresh\"];\n  tokenNames.map((tokenName) => {\n    try {\n      const token = Cookies.get(store.tokens[`${tokenName}TokenName`]);\n      store.tokens[`${tokenName}Token`] = token;\n\n      // Set the user object whenever the ID token is set\n      if (tokenName === \"id\" && token) {\n        setUser();\n      }\n    } catch (error) {\n      console.warn(`Problem setting ${tokenName} token.`);\n    }\n  });\n}\n\n/**\n * Set the store token values to undefined\n */\nexport function unsetTokens() {\n  store.tokens.accessToken = undefined;\n  store.tokens.idToken = undefined;\n  store.tokens.refreshToken = undefined;\n  unsetUser();\n}\n\n/**\n * Export the store.tokens object\n */\nexport const tokens = store.tokens;\n\n// NOTE Commenting this out 6/11/21 because the packages it relies on (jsonwebtoken & jwks-rsa)\n// both cause a lot of bloat. If we want to verify tokens, this is a nice way to do it, but\n// we need to find libraries designed for the browser instead of node.\n/**\n * Verify the provided token\n * @param {String} token\n * @returns {Promise<void>} The provided token has been verified if `verifyToken` resolves without error\n */\n// export async function verifyToken(token) {\n//   if (!token) throw new Error(\"Missing token\");\n\n//   let publicKey;\n//   try {\n//     const decodedToken = jwt.decode(token, { complete: true });\n//     if (!decodedToken.header || !decodedToken.header.kid) {\n//       throw new Error(\"Token kid not defined\");\n//     }\n\n//     const client = new JwksClient({\n//       jwksUri: `${apiUrl}tenants/${store.tenantId}/jwks/${store.mode}`,\n//       requestHeaders: { origin: window.location.origin },\n//     });\n\n//     const key = await client.getSigningKey(decodedToken.header.kid);\n//     publicKey = key.getPublicKey();\n//   } catch (error) {\n//     throw error;\n//   }\n\n//   if (!publicKey) {\n//     throw new Error(\"Public key not found\");\n//   }\n\n//   try {\n//     jwt.verify(token, publicKey);\n//   } catch (error) {\n//     throw new Error(\"Token verification failed\");\n//   }\n\n//   return Promise.resolve();\n// }\n","import Cookies from \"js-cookie\";\nimport axios from \"axios\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\n// import { getIframe, postMessageAsPromise } from \"./iframe.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Refresh the access and ID tokens\n * - When in test mode, uses the basic refresh method\n * - For tenants without a custom SSL certificate, uses the basic refresh method\n * - For tenants with a custom SSL certificate and in live mode, uses the httpOnly refresh method\n * @returns {Promise}\n */\nexport async function refresh() {\n  try {\n    await basicRefresh();\n  } catch (error) {\n    console.warn(`Refresh failed: ${error.message}`);\n  }\n}\n\n/**\n * Use a regular (non-httpOnly) cookie to refresh the access and ID tokens.\n *\n * The basic refresh method is used automatically in test mode and in live\n * mode whenever an SSL certificate has not been set up.\n */\nasync function basicRefresh() {\n  const refreshToken = Cookies.get(store.tokens.refreshTokenName);\n  try {\n    const { data, status } = await axios.get(`${store.baseUrl}auth/refresh`, {\n      headers: {\n        authorization: `Bearer ${refreshToken}`,\n      },\n    });\n    if (status !== 200) {\n      throw new Error(data.message || \"Problem with request\");\n    }\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      return data;\n    } else {\n      throw new Error(\"Problem setting cookies\");\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n// TODO re-enable httpOnly refresh method once new endpoints are stable [06/15/21]\n/**\n *\n * The httpOnly refresh method is only available for tenants with configured\n * SSL certificates while in live mode.\n */\n// async function httpOnlyRefresh() {\n//   const iframe = getIframe();\n//   if (!iframe) return;\n//   return postMessageAsPromise({\n//     type: \"refresh\",\n//     tenantId: store.tenantId,\n//   });\n// }\n\n/**\n * Use a sessionId and nonce to set the iframe refresh token\n * @param {String} sessionId\n * @param {String} nonce\n * @returns {Promise}\n */\nexport async function exchange({ sessionId, nonce }) {\n  return;\n\n  // TODO re-enable httpOnly exchange method once new endpoints are stable [06/15/21]\n  // --------------------------\n  // const iframe = getIframe();\n  // if (!iframe) return;\n  // return postMessageAsPromise({\n  //   type: \"exchange\",\n  //   tenantId: store.tenantId,\n  //   payload: {\n  //     sessionId,\n  //     nonce,\n  //   },\n  // });\n}\n","import axios from \"axios\";\n\nimport { store } from \"./store.js\";\nimport { removeAllCookies } from \"./cookies.js\";\n\n/**\n * Get the value of a query attribute, e.g. ?attr=value\n * @param {String} attrName\n */\nexport function getQueryAttr(attrName) {\n  if (\n    typeof window !== \"object\" ||\n    typeof window.location !== \"object\" ||\n    !window.location.href ||\n    window.location.href.indexOf(`${attrName}=`) < 0\n  ) {\n    return;\n  }\n  return decodeURIComponent(\n    window.location.href.split(`${attrName}=`)[1].split(\"&\")[0]\n  );\n}\n\n// TODO replace with direct check of the access token.\n/**\n * If the access token is valid, redirect the browser to the\n * tenant's login redirection path (path after login).\n */\nexport async function redirectIfLoggedIn({ redirect } = {}) {\n  if (!store.tokens.accessToken) {\n    return removeAllCookies();\n  }\n\n  // Redirect to a provided path (check options first, then url querystring)\n  if (redirect) {\n    return redirectToPath(redirect);\n  } else if (getQueryAttr(\"redirect\")) {\n    return redirectToPath(getQueryAttr(\"redirect\"));\n  }\n\n  // If no path was provided, look up the path and then redirect there\n  try {\n    const { data } = await axios.get(`${store.baseUrl}self`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n    if (data.tenant && data.tenant.loginRedirectPath) {\n      redirectToPath(data.tenant.loginRedirectPath);\n    }\n  } catch (err) {\n    removeAllCookies();\n  }\n}\n\n/**\n * Redirect to path portion of a URL.\n */\nexport function redirectToPath(pathOrUrl) {\n  // Return if no pathOrUrl, or if SSR or mobile\n  if (\n    !pathOrUrl ||\n    typeof document !== \"object\" ||\n    typeof window !== \"object\"\n  ) {\n    return;\n  }\n  try {\n    document && window;\n  } catch (error) {\n    return;\n  }\n\n  // Perform hard redirect\n  const el = document.createElement(\"a\");\n  el.href = pathOrUrl;\n  let path = `${el.pathname}${el.hash}${el.search}`;\n  if (el.pathname !== window.location.pathname) {\n    window.location.assign(path);\n  }\n}\n","import axios from \"axios\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { getQueryAttr, redirectToPath } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Send an SMS to a phone number\n * @param {String} type Type of SMS to send\n * @param {String} to Phone number in E.164 format\n * @param {String} firstFactorCode Identifier obtained from login() response\n * @returns {Object}\n */\nexport async function sendSms({ type, to, firstFactorCode } = {}) {\n  if (!type) {\n    throw new Error('Userfront.sendSms called without \"type\" property.');\n  }\n\n  switch (type) {\n    case \"securityCode\":\n      if (!to || !firstFactorCode) {\n        throw new Error(\n          'Userfront.sendSms type \"securityCode\" requires \"to\" and \"firstFactorCode\".'\n        );\n      }\n\n      return sendSecurityCode({\n        firstFactorCode,\n        to,\n        strategy: \"securityCode\",\n        channel: \"sms\",\n      });\n    default:\n      throw new Error('Userfront.sendSms called with invalid \"type\" property.');\n  }\n}\n\n/**\n * Send an MFA security code\n * @param {String} firstFactorCode Identifier obtained from login() response\n * @param {String} strategy Type of MFA strategy\n * @param {String} channel Method of sending the security code\n * @param {String} to Phone number in E.164 format\n * @returns {Object}\n */\nexport async function sendSecurityCode({\n  firstFactorCode,\n  strategy,\n  channel,\n  to,\n} = {}) {\n  if (!firstFactorCode || !strategy || !channel || !to) {\n    throw new Error(\"Userfront.sendSecurityCode missing parameters.\");\n  }\n\n  try {\n    const { data } = await axios.post(`${store.baseUrl}auth/mfa`, {\n      tenantId: store.tenantId,\n      firstFactorCode,\n      strategy,\n      channel,\n      to,\n    });\n\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log in using firstFactorCode and MFA security code\n * @param {String} firstFactorCode Identifier obtained from login() response\n * @param {String} securityCode Code provided by the user\n * @param {String|Boolean} redirect Redirect to given path unless specified as `false`\n * @returns {Object}\n */\nexport async function loginWithSecurityCode({\n  firstFactorCode,\n  securityCode,\n  redirect,\n} = {}) {\n  if (!firstFactorCode || !securityCode) {\n    throw new Error(\"Userfront.loginWithSecurityCode missing parameters.\");\n  }\n\n  try {\n    const { data } = await axios.put(`${store.baseUrl}auth/mfa`, {\n      tenantId: store.tenantId,\n      firstFactorCode,\n      securityCode,\n    });\n\n    setCookiesAndTokens(data.tokens);\n    await exchange(data);\n    if (redirect === false) {\n      return data;\n    }\n\n    redirectToPath(\n      redirect || getQueryAttr(\"redirect\") || data.redirectTo || \"/\"\n    );\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import axios from \"axios\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { getQueryAttr, redirectToPath } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\nimport { loginWithSecurityCode } from \"./mfa.js\";\n\n/**\n * This file has methods for signing up and logging in\n */\n\n/**\n * Register a user via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @param {String} method\n * @param {String} username\n * @param {String} name\n * @param {String} email\n * @param {String} password\n * @param {Object} data - Object for custom user fields\n * @param {String} redirect - path to redirect to, or if false, do not redirect\n */\nexport async function signup({\n  method,\n  username,\n  name,\n  email,\n  password,\n  data,\n  redirect,\n} = {}) {\n  if (!method) {\n    throw new Error('Userfront.signup called without \"method\" property.');\n  }\n  switch (method) {\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n      return signupWithSSO({ provider: method, redirect });\n    case \"password\":\n      return signupWithPassword({\n        username,\n        name,\n        email,\n        password,\n        userData: data,\n        redirect,\n      });\n    case \"passwordless\":\n      return sendPasswordlessLink({ email, name, username, userData: data });\n    default:\n      throw new Error(\n        'Userfront.signup called with invalid \"method\" property.'\n      );\n  }\n}\n\n/**\n * Register a new user in via SSO provider.\n * Redirect the browser after successful authentication and 302 redirect from server.\n * @param {String} provider Name of SSO provider\n */\nfunction signupWithSSO({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  const url = getProviderLink({ provider, redirect });\n  window.location.assign(url);\n}\n\n/**\n * Register a new user with username, name, email, and password.\n * Redirect the browser after successful signup based on the redirectTo value returned.\n * @param {String} username\n * @param {String} name\n * @param {String} email\n * @param {String} password\n * @param {Object} userData - alias for the user.data object, since \"data\" is used in the response\n * @param {String} redirect - do not redirect if false, or redirect to a specific path\n */\nasync function signupWithPassword({\n  username,\n  name,\n  email,\n  password,\n  userData,\n  redirect,\n} = {}) {\n  try {\n    const { data } = await axios.post(`${store.baseUrl}auth/create`, {\n      tenantId: store.tenantId,\n      username,\n      name,\n      email,\n      password,\n      data: userData,\n    });\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      if (redirect === false) return data;\n      redirectToPath(\n        redirect || getQueryAttr(\"redirect\") || data.redirectTo || \"/\"\n      );\n      return data;\n    } else {\n      throw new Error(\"Please try again.\");\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log a user in via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @param {String} method\n * @param {String} email\n * @param {String} username\n * @param {String} emailOrUsername\n * @param {String} password\n * @param {String} token\n * @param {String} uuid\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function login({\n  method,\n  email,\n  username,\n  emailOrUsername,\n  password,\n  token,\n  uuid,\n  firstFactorCode,\n  securityCode,\n  redirect,\n} = {}) {\n  if (!method) {\n    throw new Error('Userfront.login called without \"method\" property.');\n  }\n  switch (method) {\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n      return loginWithSSO({ provider: method, redirect });\n    case \"password\":\n      return loginWithPassword({\n        email,\n        username,\n        emailOrUsername,\n        password,\n        redirect,\n      });\n    case \"passwordless\":\n      return sendPasswordlessLink({ email });\n    case \"link\":\n      return loginWithLink({ token, uuid, redirect });\n    case \"mfa\":\n      return loginWithSecurityCode({ firstFactorCode, securityCode, redirect });\n    case \"saml\":\n      return completeSamlLogin();\n    default:\n      throw new Error('Userfront.login called with invalid \"method\" property.');\n  }\n}\n\n/**\n * Log a user in via SSO provider.\n * Redirect the browser after successful authentication and 302 redirect from server.\n * @param {String} provider Name of SSO provider\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nfunction loginWithSSO({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  const url = getProviderLink({ provider, redirect });\n  window.location.assign(url);\n}\n\nexport function getProviderLink({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  if (!store.tenantId) throw new Error(\"Missing tenant ID\");\n\n  let url = `${store.baseUrl}auth/${provider}/login?tenant_id=${store.tenantId}&origin=${window.location.origin}`;\n\n  let redirectTo = redirect || getQueryAttr(\"redirect\");\n  if (redirect === false) {\n    redirectTo = typeof document === \"object\" && document.location.pathname;\n  }\n  if (redirectTo) {\n    url += `&redirect=${encodeURIComponent(redirectTo)}`;\n  }\n\n  return url;\n}\n\n/**\n * Log a user in with email/username and password.\n * Redirect the browser after successful login based on the redirectTo value returned.\n * @param {Object} options\n */\nasync function loginWithPassword({\n  email,\n  username,\n  emailOrUsername,\n  password,\n  redirect,\n}) {\n  try {\n    const { data } = await axios.post(`${store.baseUrl}auth/basic`, {\n      tenantId: store.tenantId,\n      emailOrUsername: email || username || emailOrUsername,\n      password,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      if (redirect === false) return data;\n      redirectToPath(\n        redirect || getQueryAttr(\"redirect\") || data.redirectTo || \"/\"\n      );\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Please try again.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\nasync function completeSamlLogin() {\n  try {\n    if (!store.tokens.accessToken) {\n      return console.warn(\"Cannot complete SAML login without access token\");\n    }\n\n    const { data } = await axios.get(`${store.baseUrl}auth/saml/idp/token`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    window.location.assign(\n      `${store.baseUrl}auth/saml/idp/login?tenant_id=${store.tenantId}&token=${data.token}&uuid=${store.user.userUuid}`\n    );\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log a user in with a token/uuid combo passed into the function or\n * in the URL querystring. ?token=...&uuid=...\n * @param {String} token\n * @param {UUID} uuid\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithLink({ token, uuid, redirect } = {}) {\n  try {\n    token = token || getQueryAttr(\"token\");\n    uuid = uuid || getQueryAttr(\"uuid\");\n    if (!token || !uuid) return;\n\n    const { data } = await axios.put(`${store.baseUrl}auth/link`, {\n      token,\n      uuid,\n      tenantId: store.tenantId,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      if (redirect === false) return data;\n      redirectToPath(\n        redirect || getQueryAttr(\"redirect\") || data.redirectTo || \"/\"\n      );\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Problem logging in.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Send a login link to the provided email.\n * @param {String} email\n */\nexport async function sendLoginLink(email) {\n  try {\n    const { data } = await axios.post(`${store.baseUrl}auth/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Create or update a user and send them a link to log in.\n * @param {Object} inputs\n */\nexport async function sendPasswordlessLink({\n  email,\n  name,\n  username,\n  userData,\n  options,\n}) {\n  try {\n    const { data } = await axios.post(`${store.baseUrl}auth/link`, {\n      email,\n      name,\n      username,\n      data: userData,\n      options,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Send a password reset link to the provided email.\n * @param {String} email\n */\nexport async function sendResetLink(email) {\n  try {\n    const { data } = await axios.post(`${store.baseUrl}auth/reset/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\nexport async function resetPassword({ uuid, token, password, redirect }) {\n  try {\n    token = token || getQueryAttr(\"token\");\n    uuid = uuid || getQueryAttr(\"uuid\");\n    if (!token || !uuid) throw new Error(\"Missing token or uuid\");\n    const { data } = await axios.put(`${store.baseUrl}auth/reset`, {\n      tenantId: store.tenantId,\n      uuid,\n      token,\n      password,\n    });\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n\n      // Return if redirect is explicitly false\n      if (redirect === false) return data;\n\n      redirectToPath(\n        redirect || getQueryAttr(\"redirect\") || data.redirectTo || \"/\"\n      );\n\n      return data;\n    } else {\n      throw new Error(\n        \"There was a problem resetting your password. Please try again.\"\n      );\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import axios from \"axios\";\n\nimport { getIframe, postMessageAsPromise } from \"./iframe.js\";\nimport { store } from \"./store.js\";\nimport { removeAllCookies } from \"./cookies.js\";\nimport { setTokensFromCookies } from \"./tokens.js\";\nimport { redirectToPath } from \"./url\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Log a user out and redirect to the logout path.\n */\nexport async function logout({ method, redirect } = {}) {\n  if (method === \"saml\") {\n    return completeSamlLogout();\n  }\n  if (!store.tokens.accessToken) {\n    return removeAllCookies();\n  }\n\n  try {\n    const { data } = await axios.get(`${store.baseUrl}auth/logout`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n    removeAllCookies();\n    if (redirect === false) return;\n    redirectToPath(redirect || data.redirectTo);\n  } catch (err) {\n    removeAllCookies();\n  }\n}\n\nasync function completeSamlLogout() {\n  if (!store.tokens.accessToken) {\n    throw new Error(\"Please log in to authorize your logout request.\");\n  }\n\n  try {\n    const { data } = await axios.get(`${store.baseUrl}auth/saml/idp/token`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    window.location.assign(\n      `${store.baseUrl}auth/saml/idp/logout?tenant_id=${store.tenantId}&token=${data.token}&uuid=${store.user.userUuid}`\n    );\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n// TODO re-enable exchange method once new endpoints are stable [06/15/21]\n// --------------------------\n// const iframe = getIframe();\n// if (!iframe) return;\n// try {\n//   const { data } = await postMessageAsPromise({\n//     type: \"logout\",\n//     tenantId: store.tenantId,\n//   });\n//   removeAllCookies();\n//   setTokensFromCookies();\n//   redirectToPath(data.redirectTo || \"/\");\n// } catch (error) {\n//   removeAllCookies();\n//   redirectToPath(\"/\");\n// }\n","export const apiUrl = `https://api.userfront.com/v0/`;\n\nexport const privateIPRegex =\n  /((^127\\.)|(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.))\\d{1,3}\\.\\d{1,3}/g;\n","import axios from \"axios\";\nimport { privateIPRegex } from \"./constants.js\";\nimport { store } from \"./store.js\";\n\n/**\n * Global mode object\n */\nexport const mode = {\n  value: \"live\",\n  reason: undefined,\n  setMode,\n};\n\nsetModeSync();\n\n/**\n * Determine whether a hostname is in test mode.\n * @param {String} hn\n */\nexport function isTestHostname(hn) {\n  try {\n    const hostname = hn || window.location.hostname;\n    return !!(hostname.match(/localhost/g) || hostname.match(privateIPRegex));\n  } catch (err) {\n    return true;\n  }\n}\n\nexport function isHttps() {\n  try {\n    return window.location.protocol === \"https:\";\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Define the mode of operation (live or test)\n */\nexport async function setMode() {\n  try {\n    const { data } = await axios.get(\n      `${store.baseUrl}tenants/${store.tenantId}/mode`\n    );\n    mode.value = data.mode || \"test\";\n    mode.reason = getReason(mode.value);\n    store.mode = mode.value;\n  } catch (err) {\n    mode.value = \"test\";\n    store.mode = mode.value;\n  }\n}\n\n/**\n * Estimate the mode without making an API call\n */\nexport function setModeSync() {\n  const modeValue = isTestHostname() || !isHttps() ? \"test\" : \"live\";\n  mode.value = modeValue;\n  mode.reason = getReason(modeValue);\n  store.mode = modeValue;\n}\n\n/**\n * Set the reason for the mode\n * - http\n * - domain\n */\nfunction getReason(mode) {\n  try {\n    if (mode === \"live\") {\n      return \"domain\";\n    }\n    if (window.location.protocol === \"http:\") {\n      return \"http\";\n    } else if (window.location.protocol !== \"https:\") {\n      return \"protocol\";\n    } else {\n      return \"domain\";\n    }\n  } catch (error) {}\n}\n","/**\n * user methods are refactored into a separate file to avoid a circular dependency\n * between Userfront.refresh() [which requires setUser()]\n * and Userfront.user.update() [which requires refresh()].\n */\n\nimport axios from \"axios\";\nimport { refresh } from \"./refresh.js\";\nimport { store } from \"./store.js\";\nimport { getJWTPayload } from \"./utils.js\";\n\n/**\n * Update the user record on Userfront\n * @param {Object} payload User properties to update e.g. { name: 'John Doe' }\n */\nexport async function update(payload) {\n  if (!payload || Object.keys(payload).length < 1) {\n    return console.warn(\"Missing user properties to update\");\n  }\n\n  // Make request to update the user\n  await axios.put(`${store.baseUrl}self`, payload, {\n    headers: {\n      authorization: `Bearer ${store.tokens.accessToken}`,\n    },\n  });\n\n  // Refresh the access and ID tokens, and set the store.user object from the ID token\n  await refresh();\n\n  return store.user;\n}\n\n/**\n * Determine whether the access token has a given role\n * @param {String} roleName\n * @param {Object} options\n * @returns {Boolean}\n */\nexport function hasRole(roleName, { tenantId } = {}) {\n  try {\n    if (!store.tokens.accessToken || !store.tenantId) {\n      return false;\n    }\n    const { authorization } = getJWTPayload(store.tokens.accessToken);\n    if (!authorization) {\n      return false;\n    }\n    tenantId = tenantId || store.tenantId;\n    if (!authorization[tenantId] || !authorization[tenantId].roles) {\n      return false;\n    }\n    return authorization[tenantId].roles.indexOf(roleName) > -1;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Add the methods to the store.user object\n */\nstore.user.update = update;\nstore.user.hasRole = hasRole;\n","import axios from \"axios\";\nimport { store } from \"./store.js\";\nimport {\n  tokens,\n  accessToken,\n  idToken,\n  setTokensFromCookies,\n  setTokenNames,\n} from \"./tokens\";\nimport { redirectIfLoggedIn } from \"./url.js\";\nimport { sendSms } from \"./mfa.js\";\nimport {\n  login,\n  resetPassword,\n  sendLoginLink,\n  sendResetLink,\n  signup,\n} from \"./signon.js\";\nimport { logout } from \"./logout.js\";\nimport { mode, setMode, setModeSync } from \"./mode.js\";\n// import { setIframe } from \"./iframe.js\";\nimport { user } from \"./user.js\";\nimport \"./user.methods.js\";\nimport { refresh } from \"./refresh.js\";\nimport { apiUrl } from \"./constants.js\";\n\nlet initCallbacks = [];\n\n/**\n * Initialize the Userfront library.\n * @param {String} tenantId\n */\nfunction init(tenantId, opts = {}) {\n  if (!tenantId) return console.warn(\"Userfront initialized without tenant ID\");\n\n  store.tenantId = tenantId;\n\n  store.baseUrl = opts.baseUrl || apiUrl;\n  if (!store.baseUrl.endsWith(\"/\")) {\n    store.baseUrl += \"/\";\n  }\n\n  if (opts.domain) {\n    store.domain = opts.domain;\n    axios.defaults.headers.common[\n      \"x-application-id\"\n    ] = `https://${store.domain}`;\n  }\n\n  setTokenNames();\n  // setIframe(); // TODO re-enable when iframe is needed\n  setTokensFromCookies();\n  setModeSync();\n\n  try {\n    if (initCallbacks.length > 0) {\n      initCallbacks.forEach((cb) => {\n        if (!cb || typeof cb !== \"function\") return;\n        cb({ tenantId });\n      });\n    }\n    initCallbacks = [];\n  } catch (error) {}\n}\n\n/**\n * Add a callback function to be called upon Userfront.init()\n * @param {Function} cb\n */\nfunction addInitCallback(cb) {\n  if (!cb || typeof cb !== \"function\") return;\n  initCallbacks.push(cb);\n}\n\n/**\n\n * Register a window-level event called \"urlchanged\" that will fire\n * whenever the browser URL changes.\n */\nlet isRegistered = false;\nfunction registerUrlChangedEventListener() {\n  if (isRegistered) return;\n  isRegistered = true;\n  try {\n    history.pushState = ((f) =>\n      function pushState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"pushstate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.pushState);\n\n    history.replaceState = ((f) =>\n      function replaceState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"replacestate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.replaceState);\n\n    window.addEventListener(\"popstate\", () => {\n      window.dispatchEvent(new Event(\"urlchanged\"));\n    });\n  } catch (error) {}\n}\n\n/**\n * EXPORTS\n */\n\nexport default {\n  // index\n  addInitCallback,\n  init,\n  registerUrlChangedEventListener,\n\n  //logout\n  logout,\n\n  // mode\n  mode,\n  setMode,\n\n  // refresh\n  refresh: (a, b, c) => {\n    try {\n      console.warn(\n        \"Userfront.refresh() is deprecated and will be removed. Please use Userfront.tokens.refresh() instead.\"\n      );\n    } catch (error) {}\n    return refresh(a, b, c);\n  },\n\n  // signon\n  login,\n  resetPassword,\n  sendLoginLink,\n  sendResetLink,\n  signup,\n\n  // store\n  store,\n\n  // tokens\n  tokens,\n  accessToken,\n  idToken,\n\n  // url\n  redirectIfLoggedIn,\n\n  // user\n  user,\n\n  // mfa\n  sendSms,\n\n  // utils\n};\n"],"names":["store","user","tokens","mode","getJWTPayload","token","encodedPayload","split","replace","JSON","parse","atob","error","console","throwFormattedError","Error","response","_error$response","data","_error$response$data","message","setCookie","value","options","type","cookieName","tenantId","secure","sameSite","Cookies","set","removeCookie","name","paths","domains","path","window","location","pathname","hostname","primaryDomain","slice","join","undefined","err","map","domain","remove","removeAllCookies","accessTokenName","idTokenName","refreshTokenName","accessToken","idToken","refreshToken","attr","unsetUser","setCookiesAndTokens","access","cookieOptions","id","refresh","setTokensFromCookies","body","recover","result","e","then","exchange","get","axios","baseUrl","headers","authorization","status","basicRefresh","warn","tokenName","idTokenPayload","propsToDefine","prop","setUser","getQueryAttr","attrName","href","indexOf","decodeURIComponent","redirectToPath","pathOrUrl","document","el","createElement","assign","hash","search","sendPasswordlessLink","email","username","userData","post","getProviderLink","provider","redirect","url","origin","redirectTo","encodeURIComponent","privateIPRegex","setMode","reason","getReason","setModeSync","modeValue","hn","match","isTestHostname","protocol","isHttps","update","payload","Object","keys","length","put","hasRole","roleName","roles","initCallbacks","isRegistered","addInitCallback","cb","push","init","opts","endsWith","defaults","common","forEach","registerUrlChangedEventListener","history","pushState","f","ret","apply","this","arguments","dispatchEvent","Event","replaceState","addEventListener","logout","method","userUuid","completeSamlLogout","a","b","c","login","emailOrUsername","password","uuid","firstFactorCode","securityCode","loginWithSSO","hasOwnProperty","_exit2","loginWithPassword","_exit","loginWithLink","loginWithSecurityCode","completeSamlLogin","resetPassword","sendLoginLink","sendResetLink","signup","signupWithSSO","signupWithPassword","redirectIfLoggedIn","tenant","loginRedirectPath","sendSms","to","strategy","channel","sendSecurityCode"],"mappings":"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"}